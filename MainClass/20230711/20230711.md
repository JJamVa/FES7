# 20230711 정리

---

## Layout History

### 1. 단순한 텍스트 나열

- 레이아웃 도구가 없던 시절 텍스트 정렬만 가능했다.

### 2. 테이블로 레이아웃 구성

- `table`표를 본 목적과 다르게 사용
- 의미 접근성 없는 시절

```
* 뉴스레터는 현재까지 테이블 레이아웃으로 구현
```

### 3. 프레임으로 레아아웃 구성

- 여러 HTML 페이지를 `frame`을 사용하여 레이아웃 만들었다.

### 4. div div div div....

- Box Model, float, position 등 레이아웃을 만들었다.
- 브라우저별 표준이 정의가 되지 않아 기법이 엄청 다양했다. ex) explorer

### 5. 시맨틱 마크업, flex, grid

- 다양한 웹 기술의 발전, 검색엔진최적화, 접근성, 다양한 글로벌 웹사이트 제작, 반응형 등의 이유로 생겨난 레이아웃 기법.

```
* 시멘틱 마크업 꼭 써야하나요? -> 네
1. 검색엔진 최적화
2. 장애가 있는 사용자에게 페이지를 탐색할 때 하나의 푯말 역할
3. 태그의 가독성 및 유지보수 용이

현재 대부분의 브라우저가 웹표준을 따르고 있어서 시맨틱 마크업을 필수 사용.

구버전 브라우저나 다른 프로그램와의 호환을 생각하고 있다면 필수는 아니다.
```

---

## Sections

### header

- 소개 및 탐색에 도움
- 회사명, 제목, 로고 등 요소 포함
- `<head>`와 다르다
- `<header>` 안에 `<footer>` 사용 불가능, `<header>` 중첩도 불가능

### nav

- navigation bar
- 메뉴, 목차, 브레드크럼(breadcrumb)으로 사용. 현재 페이지 및 다른 페이지로의 링크를 보여줌
- 문서의 모든 링크가 `<nav>`안에 있을 필요는 없다.

### footer

- 페이지의 작성자, 저작권정보, 관련 문서 등의 내용을 담는다.

### main

- `<body>`의 주요 컨텐츠를 표현
- 웹페이지에 한번만 사용할 수 있다.
- 사이드바, 탐색 링크, 저작권정보, 사이트 로고, 검색 폼 등 여러 페이지에 반복되는 콘텐츠를 포함하면 안된다.
  - 검색 폼이 주요라면 예외

### article

- <bold>독립적</bold>으로 구분해 배포하거나 재사용할 수 있는 구획
  - 사이트에 영향을 주지않고 독립적인 기능을 수행
  - article 영역을 제거해도 페이지는 정상작동 해야됨
- 대표로 사용되는 곳은 뉴스 홈페이지
- 게시판, 블로그 글, 매거진, 뉴스 기사, 위젯, 실시간 채팅 등
- 제목 요소를 자식으로 포함

### section

- 제목 요소를 자식으로 포함

```
article vs section vs div
독립적으로 사용한다면 article!
웹페이지의 문맥 연결성이 필요하다면 section!
단순 스타일링을 위한 것이라면 div!
```

### aside

- 문서의 주요 내용과 간접적으로 연관된 부분
- 문서의 주요 흐름을 따라가지 않고, 보조 역할을 하는 공간
- 광고 배너

### hr

- 이야기에서 장면 전환 혹은 문단 안에서 주제가 변경될 때 사용
- <bold>`<p>`태그 내의 사용은 하지 않는다.</bold>

### div

- 콘텐츠 분할 요소
- block 컨테이너
- 웹사이트 레이아웃을 만들 때 사용
- 공간을 나누는 것 외에 다른 기능은 없음.

### span

- inline 컨테이너
- 스타일을 적용하기 위해 묶어 사용(특히 text)

```
<div>와 <span>은 스타일을 위해서만 사용하자.
```

---

## float

- 한 요소가 보통 흐름으로부터 빠져 텍스트 및 인라인 요소가 그 주위를 감싸 해당 요소에 좌 우측에 배치
- `left`, `right`, `none`-> default값

```
float은 블록 레이아웃 사용을 의미함
inline, inline-block 요소에 float속성을 주면 block으로 계산되어 적용.
```

### float 해제하기

```css
.box {
  clear: both;
}
/* clear 속성을 통해 float를 해제한다. 즉, float를 사용하여 요소들이 겹치게 되거나 그 주변을 둘러 쌓을 때, float를 더 이상 사용하지 않고 그 전의 상태로 돌리고 싶다면 clear를 쓰는 것이다.*/
```

```
* 주의사항
자식 요소들이 모두 float 속성을 가진다면, 컨테이너 요소의 높이에 자식 요소들의 높이가 포함되지 않음.

해결방법
1. 부모에게 높이값을 주기
2. overflow: hidden 사용
3. clear-fix 방법
```

```css
.box {
  /* 방법1 */
  height: 200px;
  /* 방법2 */
  overflow: hidden;
}

/* 방법3 */
/* 가상 요소 */
.box::after {
  content: "";
  /* 빈 공간 생성 */
  display: block;
  /* 생성한 부분에 대하여 block 컨테이너로 지정 */
  clear: left;
  /* float를 해제한다. */
}
```

---

## <span style="color:red;">flex</span>

- `display: flex`
- 자식 요소들이 컨테이너 안 공간을 맞추기 위해 크기를 줄이거나 키우거나 정렬하거나 등 설정하는 방법
- 부모 요소 `fix-container`, 자식요소 `flex-item`
- 1차원적 레이아웃(x,y)

### flex-direction

- 컨테이너 배치 설정
- `row(가로)`, `column(세로)` , `row-reverse`, `column-reverse`
- reverse는 위치도 반대지만, 요소 값도 반대 순서로 들어간다.

### jusitify-content

- 주축을 기준으로 배열의 위치를 조절, 아이템 간의 간격 및 배치 설정
- `flex-start(시작점)`, `flex-end(도착점)`, `center(가운데)`, `space-between(양 끝점으로 부터 정렬)`, `space-around(양쪽 여백의 절반만큼 나눠갖게 정렬)`, `space-evenly(항목별로 동일한 여백)`

### <span style="color:red;">align-items, align-content</span> 

- `align-items`: 교차 축을 기준으로 정렬
- `align-content`: 컨테이너의 교차 축의 아이템들이 여러 줄일 때 사용 가능
  - `flex-wrap:wrap`인 상태에서 사용가능

### gap

- 아이템 사이의 간격을 설정할 때 사용할 수 있는 속성

### flex-wrap

- 한 줄에 배치되게 할 것인지, 가능한 영역내에서 여러 행으로 나눌지 표현을 결정

```css
flex: row wrap;
/* flex-direction, flex-wrap의 단축속성 */
```

### flexitem에 사용하는 속성

#### flex-basis

- flex-item의 초기 크기 설정
- width,height와 다른점은 축의 방향에 따라 달라진다는 것과 내부 콘텐츠에 따라 유연한 크기를 가진다.
- flex-basis값이 적용되어있다면 row일 경우 width값 무시, column은 height값 무시
- px, em 단위 값을 사용하며, 0 이외에 다른 상수값을 사용 못함

#### flex-grow \*\*\*\*

- 아이템 컨테이너 내부에서 할당할 수 있는 공간의 정도를 지정
- 형제 요소인 아이템들이 모두 같은 `flex-grow`값을 가지면, 동일한 공간을 할당
- 값이 0일 경우 늘어나지 않는다.
- `flex-grow`: 1 -> <em style="color:red;">자식 요소들이 모두 동일한 크기의 공간을 할당</em>, 2이상값 -> 특정한 하나의 자식에게 줄 경우 다른 자식요소보다 두배의 <em style="color:red;">여백 공간을 할당</em>. 만약 자식 요소들의 컨텐츠 크기가 존재한다면 그 컨텐츠 넓이에 따라 할당 받는 값이 달라진다.

```css
flex-basis: 0;
/* 여백 공간이 아니라 전체 공간을 분할 */
```

#### flex-shrink

- 아이템의 크기를 고정하거나 축소할 때 사용

#### align-self

- 부모의 `align-items` 속성을 덮어 flex-item에게 개별적인 align-items 속성을 부여
- 기본값 `stretch`

#### order

- flex-item들의 순서를 order 값에 따라 결정. 값이 작을수록 우선순위가 높다.

#### flex

```css
flex: 1 1 100px;
/* flex-grow flex-shrink flex-basis의 단축 속성 */
```

---

## 웹접근성을 고려한 숨김처리
```
스크린리더와 같은 보조도구를 사용하는 사용자에게는 필요한 정보들이 있다.
스크린리더를 사용하는 사용자는 텍스트 정보에 의지해야된다.
이를 위해 접근성을 고려한 숨김처리 기술을 꼭 알아야한다.
```

### 콘텐츠를 숨기는 방법
#### 1. `display: none;` 와 `visibility:hidden;`
- 모든 사용자에게 콘텐츠를 숨김
- 시각적흐름을 완전 제거, 스크린리더기도 무시됨.
- 모든 사용자에게 숨기고 싶을 때만 사용.

#### 2. `width: 0px;`와 `height:0px;`
- HTML/CSS로 정의된 크기가 없으면 페이지 흐름에서 제거. 대부분의 스크린리더가 읽지 않음.
- `font-size:0px;`,`line-height:0px;`은 작동할 수 있지만, 가로 공간에 차지하게됨.
- 악의적인 것으로 해석되어 검색 엔진에 불이익을 준다.(권장하지 않음)

#### 3. `text-indent: -9999px;`
- 콘텐츠를 왼쪽으로 밀어버리는 방법, 스크린리더도 해당 텍스트를 읽게 됨.
- 링크, 양식 컨트롤 또는 기타 포커스가 가능한 요소에 지정된 경우 포커스는 동작하나 페이지에서는 표시가 되지않음.

#### 4. 콘텐츠를 화면 밖으로 보내기
```css
.sr-only {
	position:absolute;
    /* 페이지 흐름에서 요소를 제거 */
	left:-9999px;
    /* 왼쪽으로 밀어버리기 */
	top:auto;
    /* 원래 위치와 동일한 위치에 수직으로 배치 */
	width:1px;
	height:1px;
	overflow:hidden;
    /* 요소 크기를 1 * 1 픽셀로 만들고 해당 픽셀에 맞지 않는 모든 항목을 숨김 */
}
```

#### 5. CSS 클립방법
```css
.a11y-hidden {
	clip: rect(1px, 1px, 1px, 1px);
    /* clip은 구버전 브라우저에 호환을 위해 작성 */
	clip-path: inset(50%);
    /* clip의 최신 버전  */
	width: 1px;
	height: 1px;
	margin: -1px;
	overflow: hidden;
	padding: 0;
	position: absolute;
}
/* 서울시청, naver, daum 등 다 비슷한 코드로 사용 중 */
/* 코드를 이해하는 것도 좋지만 snippet을 이용하여 사용하는 것이 가장 좋다. */
```

### 건너뛰기 링크(skip link)
- body 콘텐츠에서 가능한 앞쪽에 배치하는 링크로, 페이지의 주요 콘텐츠의 시작점을 알림
- header의 네비게이션과 같이 여러 페이지에서 반복되는 콘텐츠를 키보드 사용자가 쉽게 생략할 수 있도록 도와줌.
- 이용 방법은 `tap`키를 눌러 확인하고 원하는 목록을 찾고, `Enter`키를 눌러 선택한 화면으로 접근
